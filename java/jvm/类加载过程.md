# 类加载

## 加载

比如我们经常写的一个类的main启动, 首先是需要通过类加载器把主类加载到JVM中

```java
public class ClassLoadMain {

    public static final String name = "BaoYang";
    public static final int age = 24;

    Teacher teacher = new Teacher();

    public int add(){

        int a = 1, b =1 ;
        int c = a + b;
        System.out.println("c的结果是: " + c);
        return c;

    }

    public static void main(String[] args) {

        ClassLoadMain classLoadMain = new ClassLoadMain();
        classLoadMain.add();

    }

}
```

通过执行流程如下

![全过程](./images/jvm类加载全过程.png)



其中 loadClass 的类加载过程有如下几步:

 加载 >> 验证 >> 准备 >> 解析 >> 初始化 >> 使用 >> 卸载

- 加载:  从磁盘上查找并通过io读入字节码,使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口
- 验证:  检验字节码文件的准确性
- 准备:  将类的静态变量分配内存,并赋予默认值
- 解析:  将符号的引用替换为直接引用,该阶段会把一些静态方法(符号引用,比如main方法)替换为指向数据所存内存的指针或句柄等(直接引用),这是所谓的静态链接过程(类加载期间完成),动态替换是在程序运行期间完成将符号引用替换为直接引用.
- 初始化:  对类的静态变量初始化为指定的值,执行静态代码块

![加载](./images/加载_验证_准备_解析_初始化.png)

类被加载到方法区中后主要包括 运行时常量池,类型信息,字段信息,方法信息,类加载器的引用,对应class实例的引用信息.

类加载器引用: 这个类到类加载器实例的引用

对应class引用: 类加载器在加载类信息放到方法区中后,会创建一个对应的class类型的对象放到heap中,作为开发人员访问方法区中类定义的入口和切入点

注意点:  主类在运行过程中如果使用到了其他类，会逐步加载这些类，jar或者war包里的类不是一次性全部加载的,是使用到时才会加载

## 类加载和双亲委派机制

- 引导类加载器：  负责加载支撑jvm运行的位于jre的lib目录下的核心类库,比如 rt.jar , charset.jar等
- 扩展包加载器：  负责加载支撑jvm运行的位于jre的lib包目录下的ext扩展目录中的jar类包
- 应用程序类加载器:  负责加载classPath路径下的类包，主要就是加载自己写的那些类
- 自定义加载器： 负责加载用户自定义的路径下的类包

## 类加载初始化过程

JVM会启动实例sun.misc.Launcher

Launcher采用单例模式,保证jvm虚拟机内存中只有一个 Launcher 实例

在 Launcher 构造方法内部, 创建了两个类加载器,分别是 ExtClassLoader(扩展类加载器) 和 AppClassLoader(应用类加载器)

```java
    public Launcher() {
        Launcher.ExtClassLoader var1;
        try {
            // 构造扩展类加载器,构造的过程中使用(ClassLoader)null将父类的加载器设置为null
            // super(getExtURLs(var1), (ClassLoader)null, Launcher.factory);
            var1 = Launcher.ExtClassLoader.getExtClassLoader();
        } catch (IOException var10) {
            throw new InternalError("Could not create extension class loader", var10);
        }

        try {
            // 构造应用类加载器,在构造的过程中将其父类加载器设置为 ExtClassLoader
            // Launcher的loader属性值是 AppClassLoader,我们一般都是用这个类加载器来加载我们自己写的应用程序
            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError("Could not create application class loader", var9);
        }

        Thread.currentThread().setContextClassLoader(this.loader);
        String var2 = System.getProperty("java.security.manager");
        if (var2 != null) {
            SecurityManager var3 = null;
            if (!"".equals(var2) && !"default".equals(var2)) {
                try {
                    var3 = (SecurityManager)this.loader.loadClass(var2).newInstance();
                } catch (IllegalAccessException var5) {
                } catch (InstantiationException var6) {
                } catch (ClassNotFoundException var7) {
                } catch (ClassCastException var8) {
                }
            } else {
                var3 = new SecurityManager();
            }

            if (var3 == null) {
                throw new InternalError("Could not create SecurityManager: " + var2);
            }

            System.setSecurityManager(var3);
        }

    }
```



## 双亲委派

### 双亲委派流程

![双亲委派](./images/双亲委派.png)

加载某个类的时,会先委托父加载器寻找目标类,找不到再委托上层父类加载器加载，如果所有的父类加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类

双亲委派:  先找父类,不行再有子类自加载

### AppClassLoader的loadCLass

AppClassLoader中的loadCLass

```java
//   
public Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {
            int var3 = var1.lastIndexOf(46);
            if (var3 != -1) {
                SecurityManager var4 = System.getSecurityManager();
                if (var4 != null) {
                    var4.checkPackageAccess(var1.substring(0, var3));
                }
            }

            if (this.ucp.knownToNotExist(var1)) {
                Class var5 = this.findLoadedClass(var1);
                if (var5 != null) {
                    if (var2) {
                        this.resolveClass(var5);
                    }

                    return var5;
                } else {
                    throw new ClassNotFoundException(var1);
                }
            } else {
                // 调用ClassLoader的loadCLass方法
                return super.loadClass(var1, var2);
            }
        }
```

ClassLoader的loadCLass方法

```java
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        // 根据 类名字 来进行上锁
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            // 第一步,查找该类是否已经被加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                // null则是没有加载
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 如果类加载器不是null，则委派给父加载器进行加载
                        c = parent.loadClass(name, false);
                    } else {
                        // 如果父加载器为null,则委托引导类加载器加载该类
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // 如果上面还是全部没有加载到
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    // 都会调用 URLCLassLoader的findCLass方法在加载器的类路径里查找并加载该类
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
```

### 双亲委派机制好处

1. 沙箱安全机制:  自己写的jre核心类库不会被加载,这样便可以防止核心api库被篡改
2. 避免类的重复加载, 当父类已经加载了该类时,就没必要子ClassLoader再加载一次,保证被加载类的唯一性
3. 全盘委托机制:  是指一个ClassLoader装载一个类时，除非显式的使用宁外一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入

### 自定义类加载器

只需要继承java.lang.ClassLoader类, 主要重写 findClass方法

1.  loadClass(String,boolean)
2. findClass : 默认实现是空方法